设计模式  
====

## 创建型模式
* 工厂方法模式  
	* 普通工厂  
	* 多个工厂方法  
	* 静态工厂  
	
`多个工厂类图`  
![多个 工厂][manyFactory]  

`普通工厂类图`  

![普通工厂][gFactory]  
	 
* 抽象工厂模式  

`概述：`  
	类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样`一旦需要增加新的功能，直接增加新的工厂类即可`，不需要修改之前的代码。因为抽象工厂不太好理解  

`类图`  
![抽象工厂][abstractFactory]  

* 单例模式
	* 非线程
	* 线程 同步锁
	* 线程 内部类 解决同步锁异常问题
	* 线程 同步锁 解决同步锁异常问题
* 建造者模式

![建造者模式][buider]  

* 原型模式

## 结构型模式
* 适配器模式
	* 类的适配器模式
	* 对象的适配器模式
	* 接口的适配器模式
* 装饰器模式

![装饰类图][decorator]  

* 代理模式
* 外观模式
`概述：`  
	外观模式是为了解决类与类之家的依赖关系的，像spring一样，可以将类和类之间的关系配置到配置文件中，而外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接口  
`应用场景：`   
	客户端与子系统之间的解耦  
`类图：`  
![外观模式][appearance]  

* 桥接模式
`概述：`  
	桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。桥接的用意是：将抽象化与实现化解耦，使得二者可以独立变化，像我们常用的JDBC桥DriverManager一样，JDBC进行连接数据库的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不用动，原因就是JDBC提供统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了。  
`应用场景：`   
	需要把事物和其具体实现分开  
`类图：`  
![桥接模式][brige] 

* 组合模式
* 享元模式

## 行为模式
* 父类与子类
	* 策略模式
		* 策略模式能有效的减少if-else语句
	* 模板方法模式
* 两个类之间
	* 观察者模式
	* 迭代子模式
	* 责任链模式
	* 命令模式
* 类的状态
	* 备忘录模式
	* 状态模式
* 通过中间类
	* 访问者模式
	* 中介者模式（只有一个仲裁者）
	* 解释器模式（Interpreter）
	
[decorator]:img/装饰类.png

[manyFactory]:img/多个 工厂.png

[abstractFactory]:img/抽象工厂.png

[buider]:img/建造者模式.png

[gFactory]:img/普通工厂.png

[appearance]:img/外观模式.PNG

[brige]:img/桥接模式.PNG